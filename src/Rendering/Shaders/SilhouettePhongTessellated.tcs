#version 430 core

// @TODO:
// Generate data in Mesh for adjacent triangles
// Vertices 0 - 2 are the original triangle
// Vertices 3 - 5 are the adjacent triangles
//
//		    3
//        '   '
//       0-----1
//	   ' \     / '
//	 '    \   /    '
// 5  ,	   \ /    ,  4
// 		 '  2  '
//
// Now for each edge, its 'silhouetteness' can be found
// 



struct PhongPatch
{
	float termIJ;
	float termJK;
	float termIK;
};

layout(vertices = 3) out;

in vec3 vPosition[];
in vec3 vNormal[];
in vec2 vTexCoord[];

out vec3 tcPosition[];
out vec3 tcNormal[];
out vec2 tcTexCoord[];
out PhongPatch tcPhongPatch[];

uniform float innerTessLevel;
uniform float outerTessLevel;

uniform mat4 modelMat;
uniform vec3 viewPos;

float PIi(int i, vec3 q) //@TODO: Change the name of this function
{
	vec3 qMinusP = q - vPosition[i];
	return q[gl_InvocationID] - dot(qMinusP, vNormal[i]) * vNormal[i][gl_InvocationID];
}

void main()
{
	if(gl_InvocationID == 0)
	{
		float finalInnerTessLevel = innerTessLevel;
		float finalOuterTessLevel = innerTessLevel;

		if(innerTessLevel > 1 || outerTessLevel > 1)
		{
			/** Determine tessellation level from face normal for silhouette-only tessellation */
			// Find surface normal
			vec3 edge1 = vPosition[1] - vPosition[0];
			vec3 edge2 = vPosition[2] - vPosition[0];
			vec3 worldSpaceNormal = normalize(cross(edge1, edge2));

			// Find direction vector from camera to surface center
			vec3 surfaceCenter = (vPosition[0] + vPosition[1] + vPosition[2]) / 3;
			vec3 viewDir = normalize(viewPos - surfaceCenter);

			// Find angle between surface normal and (camera - surface-center) vector
			float cosine = dot(worldSpaceNormal, viewDir);

			// Adjust tessellation level based on tessellation level
			//finalInnerTessLevel = min(innerTessLevel, max(1, innerTessLevel * (1 - cosine)));
			//finalOuterTessLevel = min(outerTessLevel, max(1, outerTessLevel * (1 - cosine)));

			if(cosine > 0.3)
			{
				finalInnerTessLevel = 1;
				finalOuterTessLevel = 1;
			}

		}

		gl_TessLevelInner[0] = finalInnerTessLevel;
		gl_TessLevelOuter[0] = finalOuterTessLevel;
		gl_TessLevelOuter[1] = finalOuterTessLevel;
		gl_TessLevelOuter[2] = finalOuterTessLevel;
	}

	tcPosition[gl_InvocationID] = vPosition[gl_InvocationID];
	tcNormal[gl_InvocationID] = vNormal[gl_InvocationID];
	tcTexCoord[gl_InvocationID] = vTexCoord[gl_InvocationID];

	tcPhongPatch[gl_InvocationID].termIJ = PIi(0, vPosition[1]) + PIi(1, vPosition[0]);
	tcPhongPatch[gl_InvocationID].termJK = PIi(1, vPosition[2]) + PIi(2, vPosition[1]);
	tcPhongPatch[gl_InvocationID].termIK = PIi(2, vPosition[0]) + PIi(0, vPosition[2]);

}